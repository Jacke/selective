\section{Selective functors}\label{sec-selective}

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
class Functor f where
    fmap :: (a -> b) -> f a -> f b

-- An infix synonym for fmap
(<$>) :: Functor f => (a -> b) -> f a -> f b       -- (<$>) is pronounced as "map"

class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b              -- (<*>) is pronounced as "apply"

-- A variant of <*> with the arguments reversed
(<**>) :: Applicative f => f a -> f (a -> b) -> f b

class Applicative f => Selective f where
    select :: f (Either a b) -> f (a -> b) -> f b

-- An infix synonym for select
(<*?) :: f (Either a b) -> f (a -> b) -> f b       -- (<*?) is pronounced as "select"

class Selective f => Monad f where
    return :: a -> f a
    (>>=)  :: f a -> (a -> f b) -> f b             -- (>>=) is pronounced as "bind"
\end{minted}
\caption{The proposed type class hierarchy, where \hs{Functor}, \hs{Applicative}
and \hs{Monad} are standard Haskell type classes, and \hs{Selective} is
a new intermediate abstraction introduced between \hs{Applicative} and
\hs{Monad}.}\label{fig-types}
\end{figure}

In this section we introduce selective applicative functors, which we will
further refer to as simply \emph{selective functors}, for brevity. We start by
defining the new abstraction and using it to implement several simple
combinators, such as the aforementioned \hs{whenS}. In~\S\ref{sec-instances} we
provide several examples of selective functors, and discuss the relationships
between applicative functors, selective functors, and monads.
In~\S\ref{sec-laws}, these relationships are further elaborated and expressed
as a set of laws that all selective functors are required to satisfy.

Like applicative functors~\citep{mcbride2008applicative}, selective functors
provide a way to embed pure values into an effectful context \hs{f} using the
function \hs{pure}, and give meaning to composition of two independent effectful
computations using the operator \hs{<*>}. See Fig.~\ref{fig-types} for the
standard definition of the corresponding type class \hs{Applicative}. Selective
functors enrich the applicative interface with the \hs{select} function, which
gives meaning to the composition of two effectful computations, where, in
contrast to \hs{<*>}, the second computation \emph{may depend} on the first one:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
class Applicative f => Selective f where
    select :: f (Either a b) -> f (a -> b) -> f b
\end{minted}
\vspace{1mm}

\noindent
One can think of \hs{select} as a selective function application:
parametricity~\citep{wadler1989theorems} dictates that we \emph{must apply} the
function of type \hs{a}~\hs{->}~\hs{b} when given a value of type
\hs{Left}~\hs{a}, but we \emph{may skip} the function and associated effects,
and simply return the \hs{b} when given a \hs{Right}~\hs{b}. Following the
notational convention for applicative operators, we also define the infix
operator alias \hs{<*?} for \hs{select}: the angle bracket pointing to the left
means we always use the corresponding value; the value on the right, however,
may be skipped, hence the question mark.

Note that one can implement a function with the type signature of \hs{select}
using applicative functors, but it will always execute the effects associated
with the second argument, rendering any conditional execution of effects
impossible, as in the \hs{pingPongA} example in~\S\ref{sec-intro}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
selectA :: Applicative f => f (Either a b) -> f (a -> b) -> f b
selectA x y = (\e f -> case e of { Left a -> f a; Right b -> b }) <$> x <*> y
\end{minted}
\vspace{1mm}

\noindent
As we will see in~\S\ref{sec-instances}, the above definition is sometimes
useful, for example, selective functors used for static analysis need to collect
information about all possible effects instead of skipping some of them,
therefore directly using \hs{select}~\hs{=}~\hs{selectA} in their
\hs{Selective} instance definition.

As a first use-case of selective functors, let us revisit our ping-pong example
from~\S\ref{sec-intro} and implement the combinator \hs{whenS}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
whenS :: Selective f => f Bool -> f () -> f ()
whenS x y = selector <*? effect
  where
    selector = fmap (\b -> if b then Left () else Right ()) x
    effect   = fmap const                                   y
\end{minted}
\vspace{1mm}

\noindent
We first bring the given effectful computations into the right shape by using
the \hs{Functor}'s function \hs{fmap} (see
Fig.~\ref{fig-types}); specifically, \hs{x}~\hs{::}~\hs{f}~\hs{Bool} is
converted into a \hs{selector}~\hs{::}~\hs{f}~\hs{(Either}~\hs{()}~\hs{())}, and
\hs{y}~\hs{::}~\hs{f}~\hs{()} is converted into
\hs{effect}~\hs{::}~\hs{f}~\hs{(()}~\hs{->}~\hs{())}. The results are composed
using the select operator \hs{<*?}, and the meaning of this composition is
determined by a specific \hs{Selective} instance.
% (see some examples in~\S\ref{sec-instances}).

It is worth noting that unlike the select operator, whose implementation is
almost completely determined by parametricity (the only real question is:
\emph{"To skip, or not to skip?"}), \hs{whenS} admits a variety of (incorrect)
implementations. In particular, due to \emph{Boolean blindness}\footnote{The
term refers to the fact that the \hs{True} and \hs{False} values are not
distinguished at the type level, see~\citet{boolean-blindness}.},
it is easy to inadvertently implement \hs{unlessS}, which has the same type but
flips the meaning of the Boolean value. The ability to reason parametrically was
one of the guiding principles we used when looking for a good abstraction for
selective functors: \hs{select} provides this ability, whereas \hs{whenS} does
not.
% Constraints liberate, liberties constrain

A strong contender for being the main ingredient of selective functors is the
function \hs{branch} that, given an effectful computation
\hs{x}~\hs{::}~\hs{f}~\hs{(Either}~\hs{a}~\hs{b)}, selects which subsequent
computation, namely \hs{l}~\hs{::}~\hs{f}~\hs{(}\hs{a}~\hs{->}~\hs{c)} or
\hs{r}~\hs{::}~\hs{f}~\hs{(}\hs{b}~\hs{->}~\hs{c)}, to execute:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c
branch x l r = fmap (fmap Left) x <*? fmap (fmap Right) l <*? r
\end{minted}
\vspace{1mm}

\noindent
While we encourage the reader to derive this implementation as an exercise, we
would like to also share our intuition behind it, as it will be useful for
\emph{free selective functors} in~\S\ref{sec-free}.
The select operator allows us to eliminate one of the cases in a sum type,
namely the \hs{Left}~\hs{a} case in \hs{Either}~\hs{a}~\hs{b}, leaving the other
case intact. To implement \hs{branch}, we will need to apply \hs{<*?} twice,
eliminating \hs{a} and \hs{b} one after another. The first application is tricky
because \hs{f}~\hs{(Either}~\hs{a}~\hs{b)} and
\hs{f}~\hs{(}\hs{a}~\hs{->}~\hs{c)} do not match the type signature of \hs{<*?}.
To fix the mismatch, we convert them to
\hs{f}~\hs{(Either}~\hs{a}~\hs{(}\hs{Either}~\hs{b}~\hs{c))} and
\hs{f}~\hs{(}\hs{a}~\hs{->}~\hs{Either}~\hs{b}~\hs{c)}, respectively. The second
application of \hs{<*?} is then straightforward.

As discussed in~\S\ref{sec-alternatives}, we could have chosen to use
\hs{branch} instead of \hs{select} as the method of the \hs{Selective} type
class. Our choice of \hs{select} followed the Occam's razor principle:
\hs{select} is simpler than \hs{branch}, which, in particular, leads to a
simpler free construction (\S\ref{sec-free}).

By instantiating \hs{select} to \hs{a}~\hs{=}~\hs{b}~\hs{=}~\hs{()} we obtained
\hs{whenS}, and now we repeat this trick, obtaining another familiar combinator
\hs{ifS} from the function \hs{branch}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
ifS :: Selective f => f Bool -> f a -> f a -> f a
ifS i t e = branch (bool (Right ()) (Left ()) <$> i) (const <$> t) (const <$> e)
\end{minted}
\vspace{1mm}

\subsection{Basic examples}\label{sec-instances}

Over, under

Validation

\subsection{Laws}\label{sec-laws}

It may be illuminating to compare the following type signatures:

\begin{minted}[xleftmargin=10pt]{haskell}
(<**>) :: Applicative f => f a            -> f (a -> b) -> f b
select :: Selective   f => f (Either a b) -> f (a -> b) -> f b
(>>=)  :: Monad       f => f a            -> (a -> f b) -> f b
\end{minted}

The type signature of \hs{select} is reminiscent of both \hs{<*>} and \hs{>>=},
and indeed a selective functor is in some sense a composition of an applicative
functor and the \hs{Either} monad.


Note that it is not a requirement for selective functors to skip unnecessary
effects. It may be counterintuitive, but this makes them more useful. Why?
Typically, when executing a selective computation, you would want to skip the
effects (saving work); but on the other hand, if your goal is to statically
analyse a given selective computation and extract the set of all possible
effects (without actually executing them), then you do not want to skip any
effects, because that defeats the purpose of static analysis.

...

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c
branch x l r = fmap (fmap Left) x <*? fmap (fmap Right) l <*? r

ifS :: Selective f => f Bool -> f a -> f a -> f a
ifS i t e = branch (bool (Right ()) (Left ()) <$> i) (const <$> t) (const <$> e)

whenS :: Selective f => f Bool -> f () -> f ()
whenS x act = ifS x act (pure ())

whileS :: Selective f => f Bool -> f ()
whileS act = whenS act (whileS act)

(<||>) :: Selective f => f Bool -> f Bool -> f Bool
(<||>) a b = ifS a (pure True) b

(<&&>) :: Selective f => f Bool -> f Bool -> f Bool
(<&&>) a b = ifS a b (pure False)

anyS :: Selective f => (a -> f Bool) -> [a] -> f Bool
anyS p = foldr ((<||>) . p) (pure False)

allS :: Selective f => (a -> f Bool) -> [a] -> f Bool
allS p = foldr ((<&&>) . p) (pure True)
\end{minted}
\caption{Various conditional combinators implemented using selective functors.}
\label{fig-library}
\end{figure}