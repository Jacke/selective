\section{Selective functors}\label{sec-selective}

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
class Functor f where
    fmap :: (a -> b) -> f a -> f b

-- An infix synonym for fmap
(<$>) :: Functor f => (a -> b) -> f a -> f b       -- (<$>) is pronounced as "map"

class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b              -- (<*>) is pronounced as "apply"

-- A variant of <*> with the arguments reversed
(<**>) :: Applicative f => f a -> f (a -> b) -> f b

class Applicative f => Selective f where
    select :: f (Either a b) -> f (a -> b) -> f b

-- An infix synonym for select
(<*?) :: f (Either a b) -> f (a -> b) -> f b       -- (<*?) is pronounced as "select"

class Selective f => Monad f where
    return :: a -> f a
    (>>=)  :: f a -> (a -> f b) -> f b             -- (>>=) is pronounced as "bind"
\end{minted}
\caption{The proposed type class hierarchy, where \hs{Functor}, \hs{Applicative}
and \hs{Monad} are standard Haskell type classes, and \hs{Selective} is
a new intermediate abstraction introduced between \hs{Applicative} and
\hs{Monad}.}\label{fig-types}
\end{figure}

In this section we introduce selective applicative functors, which we will
further refer to as simply \emph{selective functors}, for brevity. We start by
defining the new abstraction, and then use it in~\S\ref{sec-combinators} to
implement several simple combinators, such as the aforementioned \hs{whenS}.
In~\S\ref{sec-instances} we provide several examples of selective functors, and
discuss the relationships between applicative functors, selective functors, and
monads. In~\S\ref{sec-laws}, these relationships are further elaborated and
expressed as a set of laws that all selective functors are required to satisfy.

Like applicative functors~\citep{mcbride2008applicative}, selective functors
provide a way to embed pure values into an effectful context \hs{f} using the
function \hs{pure}, and give meaning to composition of two \emph{independent}
effectful computations using the operator \hs{<*>}. See Fig.~\ref{fig-types} for
the standard definition of the corresponding type class \hs{Applicative}.
Selective functors enrich the applicative interface with the \hs{select}
function, which gives meaning to the composition of two effectful computations,
where, in contrast to \hs{<*>}, the second computation \emph{depends} on the
first one:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
class Applicative f => Selective f where
    select :: f (Either a b) -> f (a -> b) -> f b
\end{minted}
\vspace{1mm}

\noindent
One can think of \hs{select} as a selective function application:
parametricity~\citep{wadler1989theorems} dictates that, when given a
\hs{Left}~\hs{a}, we \emph{must execute the effects} in
\hs{f}~\hs{(}\hs{a}~\hs{->}~\hs{b)}, apply the obtained function to \hs{a}, and
return the resulting \hs{b}; on the other hand, when given a \hs{Right}~\hs{b},
we \emph{may skip the effects} associated with the function, and return the
given \hs{b}.

Following the notational convention for applicative operators, we also define the infix
operator alias \hs{<*?} for \hs{select}: the angle bracket pointing to the left
means we always use the corresponding value; the value on the right, however,
may be skipped, hence the question mark.

Note that one can implement a function with the type signature of \hs{select}
using applicative functors, but it will always execute the effects associated
with the second argument, rendering any conditional execution of effects
impossible, as in the \hs{pingPongA} example in~\S\ref{sec-intro}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
selectA :: Applicative f => f (Either a b) -> f (a -> b) -> f b
selectA x y = fmap (\e f -> case e of { Left a -> f a; Right b -> b }) x <*> y
\end{minted}
\vspace{1mm}

\noindent
As we will see in~\S\ref{sec-instances}, the above definition is sometimes
useful, for example, selective functors used for static analysis need to collect
information about all possible effects instead of skipping some of them,
hence directly using \hs{select}~\hs{=}~\hs{selectA} in their \hs{Selective}
instance definitions.

We can also implement a monadic version of the select operator, which uses the
monadic bind operator to examine the value produced by
\hs{f}~\hs{(Either}~\hs{a}~\hs{b)} and skip the subsequent effect if possible:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
selectM :: Monad f => f (Either a b) -> f (a -> b) -> f b
selectM x y = x >>= \e -> case e of Left  a -> y <*> pure a -- execute y
                                    Right b ->       pure b -- skip y
\end{minted}
\vspace{1mm}

\noindent
While \hs{selectA} is useful for \emph{static analysis}, \hs{selectM} is
useful for \emph{conditional execution} of effects. Many monads directly use
\hs{select}~\hs{=}~\hs{selectM} in their \hs{Selective} instance definitions,
and in \S\ref{sec-laws} we argue that this should in fact be a law when both
\hs{Selective}~\hs{f} and \hs{Monad}~\hs{f} instances exist.

\subsection{Selective combinators}\label{sec-combinators}

As a first use-case of selective functors, let us revisit our ping-pong example
from~\S\ref{sec-intro} and implement the combinator \hs{whenS}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
whenS :: Selective f => f Bool -> f () -> f ()
whenS x y = selector <*? effect
  where
    selector = fmap (\b -> if b then Left () else Right ()) x
    effect   = fmap const                                   y
\end{minted}
\vspace{1mm}

\noindent
We first bring the given effectful computations into the right shape by using
the \hs{Functor}'s function \hs{fmap} (see
Fig.~\ref{fig-types}); specifically, \hs{x}~\hs{::}~\hs{f}~\hs{Bool} is
converted into a \hs{selector}~\hs{::}~\hs{f}~\hs{(Either}~\hs{()}~\hs{())}, and
\hs{y}~\hs{::}~\hs{f}~\hs{()} is converted into
\hs{effect}~\hs{::}~\hs{f}~\hs{(()}~\hs{->}~\hs{())}. The results are composed
using the select operator \hs{<*?}, and the meaning of this composition is
determined by the supplied \hs{Selective}~\hs{f} instance. For example, an instance
like \hs{f}~\hs{=}~\hs{IO} would skip \hs{y} if \hs{x} yields \hs{True}, as
exploited by our implementation of \hs{pingPongS}. On the other hand, instances
used for static analysis would record both \hs{x} and \hs{y} as possible
effects. See more examples in~\S\ref{sec-instances}.

It is worth noting that unlike the select operator, whose implementation is
almost completely determined by parametricity (i.e., the only real question is:
\emph{"To skip, or not to skip?"}), \hs{whenS} admits a variety of (incorrect)
implementations. In particular, due to \emph{Boolean blindness}\footnote{The
term refers to the fact that the \hs{True} and \hs{False} values are not
distinguished at the type level, see~\citet{boolean-blindness}.},
it is easy to inadvertently implement \hs{unlessS}, which has the same type but
flips the meaning of the Boolean value. The ability to reason parametrically was
one of the guiding principles we used when looking for a good abstraction for
selective functors: \hs{select} provides this ability, whereas \hs{whenS} does
not.

% Constraints liberate, liberties constrain
% Dijkstra: "Being abstract is something profoundly different from being vague â€¦
% The purpose of abstraction is not to be vague, but to create a new semantic
% level in which one can be absolutely precise."

A strong contender for playing the first violin in selective functors is the
function \hs{branch} that, given an effectful computation
\hs{x}~\hs{::}~\hs{f}~\hs{(Either}~\hs{a}~\hs{b)}, selects which subsequent
computation, namely \hs{l}~\hs{::}~\hs{f}~\hs{(}\hs{a}~\hs{->}~\hs{c)} or
\hs{r}~\hs{::}~\hs{f}~\hs{(}\hs{b}~\hs{->}~\hs{c)}, to execute:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c
branch x l r = fmap (fmap Left) x <*? fmap (fmap Right) l <*? r
\end{minted}
\vspace{1mm}
\newpage

\begin{figure}
\begin{minted}[fontsize=\small]{haskell}
branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c
branch x l r = fmap (fmap Left) x <*? fmap (fmap Right) l <*? r

ifS :: Selective f => f Bool -> f a -> f a -> f a
ifS x t e = branch ((\b -> if b then Left@\,@() else Right@\,@()) <$> x) (const@\,@<$>@\,\blk{t}@) (const@\,@<$>@\,\blk{e}@)

whenS :: Selective f => f Bool -> f () -> f ()
whenS x y = ifS x y (pure ())

whileS :: Selective f => f Bool -> f () -- Run a computation while it yields True
whileS x = whenS x (whileS x)

(<||>) :: Selective f => f Bool -> f Bool -> f Bool
x <||> y = ifS x (pure True) y

(<&&>) :: Selective f => f Bool -> f Bool -> f Bool
x <&&> y = ifS x y (pure False)

anyS :: Selective f => (a -> f Bool) -> [a] -> f Bool
anyS p = foldr ((<||>) . p) (pure False)

allS :: Selective f => (a -> f Bool) -> [a] -> f Bool
allS p = foldr ((<&&>) . p) (pure True)

fromMaybeS :: Selective f => f a -> f (Maybe a) -> f a
fromMaybeS x mx = select (maybe (Left ()) Right <$> mx) (const <$> x)
\end{minted}
\caption{A library of selective combinators. The names and order of parameters
are inherited from the standard Haskell library. For example, \hs{fromMaybeS}
corresponds to the standard
\hs{fromMaybe}~\hs{::}~\hs{a}~\hs{->}~\hs{Maybe}~\hs{a}~\hs{->}~\hs{a} and
retains the short-circuiting behaviour, i.e. if the second argument is a
\hs{Just}, the first argument is skipped.}
\label{fig-library}
\end{figure}

% Add `orElse` and `andAlso' combinators?

\noindent
While we encourage the reader to derive an implementation of \hs{branch} as an
exercise, we would like to share our intuition behind it, as it will be useful
for \emph{free selective functors} in~\S\ref{sec-free}. The select operator
allows us to eliminate one of the cases in a sum type, namely the
\hs{Left}~\hs{a} case in \hs{Either}~\hs{a}~\hs{b}, leaving the other case
intact. To implement \hs{branch}, we will need to apply \hs{<*?} twice,
eliminating \hs{a} and \hs{b} one after another. The first application is tricky
because \hs{f}~\hs{(Either}~\hs{a}~\hs{b)} and
\hs{f}~\hs{(}\hs{a}~\hs{->}~\hs{c)} do not match the type signature of \hs{<*?}.
To fix the mismatch, we convert them to
\hs{f}~\hs{(Either}~\hs{a}~\hs{(}\hs{Either}~\hs{b}~\hs{c))} and
\hs{f}~\hs{(}\hs{a}~\hs{->}~\hs{Either}~\hs{b}~\hs{c)}, respectively. The second
application of \hs{<*?} is then straightforward.

As will be discussed in~\S\ref{sec-alternatives}, we could have chosen to use
\hs{branch} instead of \hs{select} as the method of the \hs{Selective} type
class. Our choice of \hs{select} follows the Occam's razor principle:
\hs{select} is simpler than \hs{branch}, which, in particular, leads to a
simpler free construction (\S\ref{sec-free}).

By instantiating \hs{select} with \hs{a}~\hs{=}~\hs{b}~\hs{=}~\hs{()} we have
earlier obtained \hs{whenS}. Below we repeat the same trick but with
\hs{branch}, obtaining another familiar conditional combinator \hs{ifS}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
ifS :: Selective f => f Bool -> f a -> f a -> f a
ifS x t e = branch selector (fmap const t) (fmap const e)
  where
    selector = fmap (\b -> if b then Left () else Right ()) x
\end{minted}
\vspace{1mm}

\noindent
Many conditional combinators, which are typically associated with the \hs{Monad}
type class, can be expressed using selective functors, as demonstrated in
Fig.~\ref{fig-library}, making them reusable in new contexts. In particular, the
logical combinators \hs{<||>} and \hs{<&&>} will play an important role in
improving the efficiency of the \Haxl framework in~\S\ref{sec-haxl}.

\subsection{Basic examples}\label{sec-instances}

Over, under

Validation

\subsection{Laws}\label{sec-laws}

It may be illuminating to compare the following type signatures:

\begin{minted}[xleftmargin=10pt]{haskell}
(<**>) :: Applicative f => f a            -> f (a -> b) -> f b
select :: Selective   f => f (Either a b) -> f (a -> b) -> f b
(>>=)  :: Monad       f => f a            -> (a -> f b) -> f b
\end{minted}

The type signature of \hs{select} is reminiscent of both \hs{<*>} and \hs{>>=},
and indeed a selective functor is in some sense a composition of an applicative
functor and the \hs{Either} monad.

\begin{figure}
\begin{minted}{haskell}
------------------------------------- Laws: ------------------------------------
-- Identity
@\blk{x}@ <*? pure id = either id id <$> x

-- Interchange
@\blk{x}@ *> (y <*? z) = (x *> y) <*? z

-- Associativity
@\blk{x}@ <*? (y <*? z) = (f <$> x) <*? (g <$> y) <*? (h <$> z)
  where
    f x = Right <$> x
    g y = \a -> bimap (,a) ($a) y
    h z = uncurry z

-- For selective functors that are also monads:
select = selectM
---------------------------------- Theorems: -----------------------------------
-- Apply a pure function to the result:
f <$> select x y = select (second f <$> x) ((f .) <$> y)

-- Apply a pure function to the Left case of the first argument:
select (first f <$> x) y = select x ((. f) <$> y)

-- Apply a pure function to the second argument:
select x (f <$> y) = select (first (flip f) <$> x) (flip ($) <$> y)

-- General interchange
x <*> (y <*? z) = (f <$> x <*> y) <*? (g <$> z)
  where
    f = (\ab -> bimap (, ab) ab)
    g = (\ca (c, ab) -> ab (ca c))

-- For selective functors that are also monads:
(<*>) = apS
\end{minted}
\caption{Laws and theorems of selective functors.}
\label{fig-laws}
\end{figure}

Note that it is not a requirement for selective functors to skip unnecessary
effects. It may be counterintuitive, but this makes them more useful. Why?
Typically, when executing a selective computation, you would want to skip the
effects (saving work); but on the other hand, if your goal is to statically
analyse a given selective computation and extract the set of all possible
effects (without actually executing them), then you do not want to skip any
effects, because that defeats the purpose of static analysis.

...

